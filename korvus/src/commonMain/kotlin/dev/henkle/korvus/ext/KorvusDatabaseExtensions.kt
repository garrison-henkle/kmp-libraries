@file:Suppress("unused")

package dev.henkle.korvus.ext

import dev.henkle.korvus.KorvusDatabase
import dev.henkle.korvus.KorvusResult
import dev.henkle.korvus.error.types.ResponseItemCountMismatchException
import dev.henkle.korvus.map
import dev.henkle.korvus.types.DBResult
import dev.henkle.korvus.types.KorvusCollection
import dev.henkle.korvus.types.KorvusDocument
import dev.henkle.korvus.types.QueryOneWithIncludesResult
import dev.henkle.korvus.types.QueryResult
import dev.henkle.korvus.types.TypedBatchCommandScope
import kotlinx.serialization.json.JsonElement
import kotlin.reflect.typeOf

/**
 * Inserts [document] into the database if it doesn't exist, or updates the existing document in the database
 * if it does exist.
 *
 * @param document the document to write to the database
 * @param id the id to associate with the document, or empty string to allow for the id to be generated
 * @param changeVector the change vector for the document or null if a change vector is not being used
 *
 * @return a result that indicates success when the update succeeded or failure otherwise
 */
suspend inline fun <reified T: Any> KorvusDatabase.put(
    document: T,
    id: String = "",
    changeVector: String? = null,
): KorvusResult<DBResult.Put> =
    put(document = document, id = id, changeVector = changeVector, type = typeOf<T>())

/**
 * Inserts [document] into the database if it doesn't exist, or updates the existing document in the database
 * if it does exist.
 *
 * @param document the document to write to the database
 *
 * @return a result that indicates success when the update succeeded or failure otherwise
 */
suspend inline fun <reified T: KorvusDocument<T>> KorvusDatabase.put(
    document: T,
): KorvusResult<T> =
    put(
        document = document,
        id = document.metadata.id,
        changeVector = document.metadata.changeVector,
        type = typeOf<T>(),
    ).map { result ->
        document.update(with = result)
    }

/**
 * Inserts the [documents] into the database if they do not exist, or updates the existing documents in the
 * database if they do exist.
 *
 * @param documents the list of documents to write to the database
 * @param ids the optional ids to use for [documents]. If an empty string, the id will be generated by the database
 * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
 * id in [ids] OR an empty list if no change vectors are being provided
 *
 * @return a result that indicates success when all database operations succeeded or failure otherwise
 */
suspend inline fun <reified T: Any> KorvusDatabase.put(
    documents: Collection<T>,
    ids: Collection<String> = List(size = documents.size) { "" },
    changeVectors: Collection<String?> = emptyList(),
): KorvusResult<List<DBResult.Put>> = put(
    documents = documents,
    ids = ids,
    changeVectors = changeVectors,
    type = typeOf<T>(),
)

/**
 * Inserts the [documents] into the database if they do not exist, or updates the existing documents in the
 * database if they do exist.
 *
 * @param documents the list of documents to write to the database
 *
 * @return a result that indicates success when all database operations succeeded or failure otherwise
 */
suspend inline fun <reified T: KorvusDocument<T>> KorvusDatabase.put(
    documents: Collection<T>,
): KorvusResult<List<T>> = put(
    documents = documents,
    ids = documents.map { it.metadata.id },
    changeVectors = documents.map { it.metadata.changeVector },
    type = typeOf<T>(),
).map { results ->
    if (documents.size != results.size) throw ResponseItemCountMismatchException()
    documents.zip(results).map { (document, result) ->
        document.update(with = result)
    }
}

/**
 * Deletes a document from the database.
 *
 * @param id the id of the document to delete
 * @param changeVector the change vector for the document or null if a change vector is not being used
 */
suspend inline fun <reified T: Any> KorvusDatabase.delete(
    id: String,
    changeVector: String? = null,
): KorvusResult<DBResult.Delete> =
    delete<T>(id = id, changeVector = changeVector, type = typeOf<T>())

/**
 * Deletes a document from the database.
 *
 * @param document the document to delete
 */
suspend inline fun <reified T: KorvusDocument<T>> KorvusDatabase.delete(
    document: T,
): KorvusResult<DBResult.Delete> =
    delete<T>(id = document.metadata.id, changeVector = document.metadata.changeVector, type = typeOf<T>())

/**
 * Deletes documents from the database.
 *
 * @param ids the ids of the documents to delete
 * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
 * id in [ids] OR an empty list if no change vectors are being provided
 */
suspend inline fun <reified T: Any> KorvusDatabase.delete(
    ids: Collection<String>,
    changeVectors: Collection<String?> = emptyList(),
): KorvusResult<List<DBResult.Delete>> =
    delete<T>(ids = ids, changeVectors = changeVectors, type = typeOf<T>())

/**
 * Deletes documents from the database.
 *
 * @param documents the documents to delete
 */
suspend inline fun <reified T: KorvusDocument<T>> KorvusDatabase.delete(
    documents: Collection<T>,
): KorvusResult<List<DBResult.Delete>> =
    delete<T>(
        ids = documents.map { it.metadata.id },
        changeVectors = documents.map { it.metadata.changeVector },
        type = typeOf<T>(),
    )


/**
 * Deletes documents from the database whose ids share the provided prefix.
 *
 * @param prefix the prefix of the ids to delete
 */
suspend inline fun <reified T: Any> KorvusDatabase.deleteByIDPrefix(
    prefix: String,
): KorvusResult<DBResult.Delete> =
    deleteByIDPrefix<T>(prefix = prefix, type = typeOf<T>())

/**
 * Patches a document in the database.
 *
 * @param id the id of the document to patch
 * @param patchScript the JavaScript script that will be used to patch the document. Named arguments can be created
 * by prefixing the argument name with '$' e.g. "this.name = $name"
 * @param arguments the arguments for the [patchScript]. The leading '$' should be excluded. All values should be
 * serializable as [JsonElement]s
 * @param changeVector the change vector for the document or null if a change vector is not being used
 */
suspend inline fun <reified T: Any> KorvusDatabase.patch(
    id: String,
    patchScript: String,
    arguments: Map<String, Any?> = emptyMap(),
    changeVector: String? = null,
): KorvusResult<DBResult.Patch> =
    patch<T>(
        id = id,
        patchScript = patchScript,
        arguments = arguments,
        changeVector = changeVector,
        type = typeOf<T>(),
    )

/**
 * Patches a document in the database.
 *
 * @param document the document to patch
 * @param patchScript the JavaScript script that will be used to patch the document. Named arguments can be created
 * by prefixing the argument name with '$' e.g. "this.name = $name"
 * @param arguments the arguments for the [patchScript]. The leading '$' should be excluded. All values should be
 * serializable as [JsonElement]s
 */
suspend inline fun <reified T: KorvusDocument<T>> KorvusDatabase.patch(
    document: T,
    patchScript: String,
    arguments: Map<String, Any?> = emptyMap(),
): KorvusResult<DBResult.Patch> =
    patch<T>(
        id = document.metadata.id,
        patchScript = patchScript,
        arguments = arguments,
        changeVector = document.metadata.changeVector,
        type = typeOf<T>(),
    )

/**
 * Patches documents in the database.
 *
 * @param ids the ids of the documents to patch
 * @param patchScripts the JavaScript scripts that will be used to patch the documents. There should be one patch
 * script for each id in [ids]. Named arguments can be created by prefixing the argument name with '$' e.g.
 * "this.name = $name"
 * @param arguments the arguments for the [patchScripts]. The leading '$' should be excluded. All values should be
 * serializable as [JsonElement]s. There should be one entry arguments list for each id in [ids] OR an empty list if
 * no arguments are needed for any of the scripts
 * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
 * id in [ids] OR an empty list if no change vectors are being provided
 */
suspend inline fun <reified T: Any> KorvusDatabase.patch(
    ids: Collection<String>,
    patchScripts: Collection<String>,
    arguments: Collection<Map<String, Any?>> = emptyList(),
    changeVectors: Collection<String?> = emptyList(),
): KorvusResult<List<DBResult.Patch>> =
    patch<T>(
        ids = ids,
        patchScripts = patchScripts,
        arguments = arguments,
        changeVectors = changeVectors,
        type = typeOf<T>(),
    )

/**
 * Patches documents in the database.
 *
 * @param documents the documents to patch
 * @param patchScripts the JavaScript scripts that will be used to patch the documents. There should be one patch
 * script for each document in [documents]. Named arguments can be created by prefixing the argument name with '$' e.g.
 * "this.name = $name"
 * @param arguments the arguments for the [patchScripts]. The leading '$' should be excluded. All values should be
 * serializable as [JsonElement]s. There should be one entry arguments list for each document in [documents] OR an empty
 * list if no arguments are needed for any of the scripts
 */
suspend inline fun <reified T: KorvusDocument<T>> KorvusDatabase.patch(
    documents: Collection<T>,
    patchScripts: Collection<String>,
    arguments: Collection<Map<String, Any?>> = emptyList(),
): KorvusResult<List<DBResult.Patch>> =
    patch<T>(
        ids = documents.map { it.metadata.id },
        patchScripts = patchScripts,
        arguments = arguments,
        changeVectors = documents.map { it.metadata.changeVector },
        type = typeOf<T>(),
    )

/**
 * Patches documents in the database.
 *
 * @param ids the ids of the documents to patch
 * @param patchScript the JavaScript script that will be used to patch the documents. Named arguments can be created
 * by prefixing the argument name with '$' e.g. "this.name = $name"
 * @param arguments the arguments for the [patchScript]. The leading '$' should be excluded. All values should be
 * serializable as [JsonElement]s. There should be one entry in the arguments list for each id in [ids] OR an empty
 * list if no arguments are needed for any of the scripts
 * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
 * id in [ids] OR an empty list if no change vectors are being provided
 */
suspend inline fun <reified T: Any> KorvusDatabase.patch(
    ids: Collection<String>,
    patchScript: String,
    arguments: Collection<Map<String, Any?>> = emptyList(),
    changeVectors: Collection<String?> = emptyList(),
): KorvusResult<List<DBResult.Patch>> =
    patch<T>(
        ids = ids,
        patchScript = patchScript,
        arguments = arguments,
        changeVectors = changeVectors,
        type = typeOf<T>(),
    )

/**
 * Patches documents in the database.
 *
 * @param documents the documents to patch
 * @param patchScript the JavaScript script that will be used to patch the documents. Named arguments can be created
 * by prefixing the argument name with '$' e.g. "this.name = $name"
 * @param arguments the arguments for the [patchScript]. The leading '$' should be excluded. All values should be
 * serializable as [JsonElement]s. There should be one entry in the arguments list for each document in [documents] OR
 * an empty list if no arguments are needed for any of the scripts
 */
suspend inline fun <reified T: KorvusDocument<T>> KorvusDatabase.patch(
    documents: Collection<T>,
    patchScript: String,
    arguments: Collection<Map<String, Any?>> = emptyList(),
): KorvusResult<List<DBResult.Patch>> =
    patch<T>(
        ids = documents.map { it.metadata.id },
        patchScript = patchScript,
        arguments = arguments,
        changeVectors = documents.map { it.metadata.changeVector },
        type = typeOf<T>(),
    )

/**
 * Performs a set of commands that are defined in the [commandsBlock]
 *
 * @param commandsBlock the scope in which the commands to be sent to the database are defined
 */
suspend inline fun <reified T: Any> KorvusDatabase.typedBatch(
    noinline commandsBlock: suspend TypedBatchCommandScope<T>.() -> Unit,
): KorvusResult<List<DBResult>> =
    typedBatch(type = typeOf<T>(), commandsBlock = commandsBlock)

/**
 * Retrieves a document from the database by [id]
 *
 * @param id the id of the document
 */
suspend inline fun <reified T: Any> KorvusDatabase.get(id: String): KorvusResult<T?> =
    get(id = id, type = typeOf<T>())

/**
 * Retrieves documents from the database by their [ids]
 *
 * @param ids the ids of the documents to fetch
 */
suspend inline fun <reified T: Any> KorvusDatabase.get(
    ids: Collection<String>,
): KorvusResult<List<T>> =
    get(ids = ids, type = typeOf<T>())

/**
 * Retrieves all documents from the specified collection from the database
 */
suspend inline fun <reified T: Any> KorvusDatabase.getAll(
    collection: String,
): KorvusResult<List<T>> =
    getAll(collection = collection, type = typeOf<T>())

/**
 * Retrieves all documents from the specified collection from the database
 */
suspend inline fun <reified T: KorvusDocument<T>, reified C: KorvusCollection<T>> KorvusDatabase.getAll(
    collection: C,
): KorvusResult<List<T>> =
    getAll(collection = collection.name, type = typeOf<T>())

/**
 * Performs a query on the database and returns a result
 *
 * @param query the query to perform on the database
 * @param parameters parameters that will be substituted for placeholders in the query
 */
suspend inline fun <reified T: Any> KorvusDatabase.queryOne(
    query: String,
    parameters: Map<String, Any> = emptyMap(),
): KorvusResult<T> =
    queryOne(query = query, parameters = parameters, type = typeOf<T>())

/**
 * Performs a query on the database and returns a result
 *
 * @param query the query to perform on the database
 * @param parameters parameters that will be substituted for placeholders in the query
 */
suspend inline fun <reified T: Any> KorvusDatabase.queryOneWithIncludes(
    query: String,
    parameters: Map<String, Any> = emptyMap(),
): KorvusResult<QueryOneWithIncludesResult<T>> =
    queryOneWithIncludes(query = query, parameters = parameters, type = typeOf<T>())

/**
 * Performs a query on the database and returns the results
 *
 * @param query the query to perform on the database
 * @param parameters parameters that will be substituted for placeholders in the query
 * @param start the document to start at when paging. Paging is disabled if null
 * @param pageSize the number of documents to return per page. Paging is disabled if null
 */
suspend inline fun <reified T: Any> KorvusDatabase.queryMany(
    query: String,
    parameters: Map<String, Any?> = emptyMap(),
    start: Int? = null,
    pageSize: Int? = null,
): KorvusResult<QueryResult<T>> = queryMany(
    query = query,
    parameters = parameters,
    type = typeOf<T>(),
    start = start,
    pageSize = pageSize,
)
