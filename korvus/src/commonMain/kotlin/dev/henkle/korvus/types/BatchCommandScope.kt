package dev.henkle.korvus.types

import kotlinx.serialization.json.JsonElement
import kotlin.reflect.KType

/**
 * A scope for executing batch commands to the RavenDB
 */
interface BatchCommandScope {
    /**
     * Inserts [document] into the database if it doesn't exist, or updates the existing document in the database
     * if it does exist.
     *
     * @param document the document to write to the database
     * @param changeVector the change vector for the document or null if a change vector is not being used
     * @param type the type of the document being put into the database
     *
     * @return a result that indicates success when the update succeeded or failure otherwise
     *
     * @see dev.henkle.korvus.ext.put
     */
    suspend fun <T: Any> put(document: T, id: String = "", changeVector: String? = null, type: KType)

    /**
     * Inserts the [documents] into the database if they do not exist, or updates the existing documents in the
     * database if they do exist.
     *
     * @param documents the list of documents to write to the database
     * @param ids the optional ids to use for [documents]. If an empty string, the id will be generated by the database
     * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
     * id in [ids] OR an empty list if no change vectors are being provided
     * @param type the type of the document being put into the database
     *
     * @return a result that indicates success when all database operations succeeded or failure otherwise
     *
     * @see dev.henkle.korvus.ext.put
     */
    suspend fun <T: Any> put(
        documents: Collection<T>,
        ids: Collection<String> = List(size = documents.size) { "" },
        changeVectors: Collection<String?> = emptyList(),
        type: KType,
    )

    /**
     * Deletes a document from the database.
     *
     * @param id the id of the document to delete
     * @param changeVector the change vector for the document or null if a change vector is not being used
     * @param type the type of the document being deleted
     */
    suspend fun <T: Any> delete(id: String, changeVector: String? = null, type: KType)

    /**
     * Deletes documents from the database.
     *
     * @param ids the ids of the documents to delete
     * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
     * id in [ids] OR an empty list if no change vectors are being provided
     * @param type the type of the document being deleted
     */
    suspend fun <T: Any> delete(
        ids: Collection<String>,
        changeVectors: Collection<String?> = emptyList(),
        type: KType,
    )

    /**
     * Deletes documents from the database whose ids share the provided prefix.
     *
     * @param prefix the prefix of the ids to delete
     * @param type the type of the document being patched
     */
    suspend fun <T: Any> deleteByIDPrefix(prefix: String, type: KType)

    /**
     * Patches a document in the database.
     *
     * @param id the id of the document to patch
     * @param patchScript the JavaScript script that will be used to patch the document. Named arguments can be created
     * by prefixing the argument name with '$' e.g. "this.name = $name"
     * @param arguments the arguments for the [patchScript]. The leading '$' should be excluded. All values should be
     * serializable as [JsonElement]s
     * @param changeVector the change vector for the document or null if a change vector is not being used
     * @param type the type of the document being patched
     */
    suspend fun <T: Any> patch(
        id: String,
        patchScript: String,
        arguments: Map<String, Any?> = emptyMap(),
        changeVector: String? = null,
        type: KType,
    )

    /**
     * Patches documents in the database.
     *
     * @param ids the ids of the documents to patch
     * @param patchScripts the JavaScript scripts that will be used to patch the documents. There should be one patch
     * script for each id in [ids]. Named arguments can be created by prefixing the argument name with '$' e.g.
     * "this.name = $name"
     * @param arguments the arguments for the [patchScripts]. The leading '$' should be excluded. All values should be
     * serializable as [JsonElement]s. There should be one entry arguments list for each id in [ids] OR an empty list if
     * no arguments are needed for any of the scripts
     * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
     * id in [ids] OR an empty list if no change vectors are being provided
     * @param type the type of the document being patched
     */
    suspend fun <T: Any> patch(
        ids: Collection<String>,
        patchScripts: Collection<String>,
        arguments: Collection<Map<String, Any?>> = emptyList(),
        changeVectors: Collection<String?> = emptyList(),
        type: KType,
    )

    /**
     * Patches documents in the database.
     *
     * @param ids the ids of the documents to patch
     * @param patchScript the JavaScript script that will be used to patch the documents. Named arguments can be created
     * by prefixing the argument name with '$' e.g. "this.name = $name"
     * @param arguments the arguments for the [patchScript]. The leading '$' should be excluded. All values should be
     * serializable as [JsonElement]s. There should be one entry in the arguments list for each id in [ids] OR an empty
     * list if no arguments are needed for any of the scripts
     * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
     * id in [ids] OR an empty list if no change vectors are being provided
     * @param type the type of the document being patched
     */
    suspend fun <T: Any> patch(
        ids: Collection<String>,
        patchScript: String,
        arguments: Collection<Map<String, Any?>> = emptyList(),
        changeVectors: Collection<String?> = emptyList(),
        type: KType,
    )

    /**
     * Convenience function to create a lambda that doesn't require explicit type declarations
     *
     * @param type the type of entities that will be used in the [block]
     * @param block a scope for performing batch commands with an implicit [type]
     */
    suspend fun <T: Any> withType(type: KType, block: suspend TypedBatchCommandScope<T>.() -> Unit)
}
