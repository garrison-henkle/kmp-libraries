package dev.henkle.korvus

import dev.henkle.korvus.types.BatchCommandScope
import dev.henkle.korvus.types.DBResult
import dev.henkle.korvus.types.QueryOneWithIncludesResult
import dev.henkle.korvus.types.QueryResult
import dev.henkle.korvus.types.TypedBatchCommandScope
import kotlinx.serialization.json.JsonElement
import kotlin.reflect.KType

interface KorvusDatabase {
    /**
     * The name of this database.
     */
    val name: String

    /**
     * The number of this database's replicas that will be maintained in the cluster.
     */
    val replicationFactor: Int

    /**
     * Creates this database in the current RavenDB instance.
     */
    suspend fun createDatabase(): KorvusResult<Unit>

    /**
     * Deletes this database in the current RavenDB instance.
     */
    suspend fun deleteDatabase(hardDelete: Boolean = true): KorvusResult<Unit>

    /**
     * Inserts [document] into the database if it doesn't exist, or updates the existing document in the database
     * if it does exist.
     *
     * @param document the document to write to the database
     * @param changeVector the change vector for the document or null if a change vector is not being used
     * @param type the type of the document being put into the database
     *
     * @return a result that indicates success when the update succeeded or failure otherwise
     *
     * @see dev.henkle.korvus.ext.put
     */
    suspend fun <T: Any> put(
        document: T,
        id: String = "",
        changeVector: String? = null,
        type: KType,
    ): KorvusResult<DBResult.Put>

    /**
     * Inserts the [documents] into the database if they do not exist, or updates the existing documents in the
     * database if they do exist.
     *
     * @param documents the list of documents to write to the database
     * @param ids the optional ids to use for [documents]. If an empty string, the id will be generated by the database
     * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
     * id in [ids] OR an empty list if no change vectors are being provided
     * @param type the type of the document being put into the database
     *
     * @return a result that indicates success when all database operations succeeded or failure otherwise
     *
     * @see dev.henkle.korvus.ext.put
     */
    suspend fun <T: Any> put(
        documents: Collection<T>,
        ids: Collection<String> = List(size = documents.size) { "" },
        changeVectors: Collection<String?> = emptyList(),
        type: KType,
    ): KorvusResult<List<DBResult.Put>>

    /**
     * Deletes a document from the database.
     *
     * @param id the id of the document to delete
     * @param changeVector the change vector for the document or null if a change vector is not being used
     * @param type the type of the document being deleted
     */
    suspend fun <T: Any> delete(
        id: String,
        changeVector: String? = null,
        type: KType,
    ): KorvusResult<DBResult.Delete>

    /**
     * Deletes documents from the database.
     *
     * @param ids the ids of the documents to delete
     * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
     * id in [ids] OR an empty list if no change vectors are being provided
     * @param type the type of the document being deleted
     */
    suspend fun <T: Any> delete(
        ids: Collection<String>,
        changeVectors: Collection<String?> = emptyList(),
        type: KType,
    ): KorvusResult<List<DBResult.Delete>>

    /**
     * Deletes documents from the database whose ids share the provided prefix.
     *
     * @param prefix the prefix of the ids to delete
     * @param type the type of the document being patched
     */
    suspend fun <T: Any> deleteByIDPrefix(
        prefix: String,
        type: KType,
    ): KorvusResult<DBResult.Delete>

    /**
     * Patches a document in the database.
     *
     * @param id the id of the document to patch
     * @param patchScript the JavaScript script that will be used to patch the document. Named arguments can be created
     * by prefixing the argument name with '$' e.g. "this.name = $name"
     * @param arguments the arguments for the [patchScript]. The leading '$' should be excluded. All values should be
     * serializable as [JsonElement]s
     * @param changeVector the change vector for the document or null if a change vector is not being used
     * @param type the type of the document being patched
     */
    suspend fun <T: Any> patch(
        id: String,
        patchScript: String,
        arguments: Map<String, Any?> = emptyMap(),
        changeVector: String? = null,
        type: KType,
    ): KorvusResult<DBResult.Patch>

    /**
     * Patches documents in the database.
     *
     * @param ids the ids of the documents to patch
     * @param patchScripts the JavaScript scripts that will be used to patch the documents. There should be one patch
     * script for each id in [ids]. Named arguments can be created by prefixing the argument name with '$' e.g.
     * "this.name = $name"
     * @param arguments the arguments for the [patchScripts]. The leading '$' should be excluded. All values should be
     * serializable as [JsonElement]s. There should be one entry arguments list for each id in [ids] OR an empty list if
     * no arguments are needed for any of the scripts
     * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
     * id in [ids] OR an empty list if no change vectors are being provided
     * @param type the type of the document being patched
     */
    suspend fun <T: Any> patch(
        ids: Collection<String>,
        patchScripts: Collection<String>,
        arguments: Collection<Map<String, Any?>> = emptyList(),
        changeVectors: Collection<String?> = emptyList(),
        type: KType,
    ): KorvusResult<List<DBResult.Patch>>

    /**
     * Patches documents in the database.
     *
     * @param ids the ids of the documents to patch
     * @param patchScript the JavaScript script that will be used to patch the documents. Named arguments can be created
     * by prefixing the argument name with '$' e.g. "this.name = $name"
     * @param arguments the arguments for the [patchScript]. The leading '$' should be excluded. All values should be
     * serializable as [JsonElement]s. There should be one entry in the arguments list for each id in [ids] OR an empty
     * list if no arguments are needed for any of the scripts
     * @param changeVectors the change vectors for the ids. There should be on entry in the change vectors list for each
     * id in [ids] OR an empty list if no change vectors are being provided
     * @param type the type of the document being patched
     */
    suspend fun <T: Any> patch(
        ids: Collection<String>,
        patchScript: String,
        arguments: Collection<Map<String, Any?>> = emptyList(),
        changeVectors: Collection<String?> = emptyList(),
        type: KType,
    ): KorvusResult<List<DBResult.Patch>>

    /**
     * Performs a set of commands that are defined in the [commandsBlock]
     *
     * @param commandsBlock the scope in which the commands to be sent to the database are defined
     */
    suspend fun batch(
        commandsBlock: suspend BatchCommandScope.() -> Unit,
    ): KorvusResult<List<DBResult>>

    /**
     * Performs a set of commands that are defined in the [commandsBlock]
     *
     * @param type the type of entity that will be used in this batch
     * @param commandsBlock the scope in which the commands to be sent to the database are defined
     */
    suspend fun <T: Any> typedBatch(
        type: KType,
        commandsBlock: suspend TypedBatchCommandScope<T>.() -> Unit,
    ): KorvusResult<List<DBResult>>

    /**
     * Retrieves a document from the database by [id]
     *
     * @param id the id of the document
     * @param type the type of the entity that is being fetched
     */
    suspend fun <T: Any> get(id: String, type: KType): KorvusResult<T?>

    /**
     * Retrieves documents from the database by their [ids]
     *
     * @param ids the ids of the documents to fetch
     * @param type the type of the entity that is being fetched
     */
    suspend fun <T: Any> get(ids: Collection<String>, type: KType): KorvusResult<List<T>>

    /**
     * Retrieves all documents from the specified collection from the database
     *
     * @param type the type of the entities that are being fetched
     */
    suspend fun <T: Any> getAll(collection: String, type: KType): KorvusResult<List<T>>

    /**
     * Performs a query on the database and returns a result
     *
     * @param query the query to perform on the database
     * @param parameters parameters that will be substituted for placeholders in the query
     * @param type the type of the entity that is returned from the server
     */
    suspend fun <T: Any> queryOne(
        query: String,
        parameters: Map<String, Any> = emptyMap(),
        type: KType,
    ): KorvusResult<T>

    /**
     * Performs a query on the database and returns a result
     *
     * @param query the query to perform on the database
     * @param parameters parameters that will be substituted for placeholders in the query
     * @param type the type of the entity that is returned from the server
     */
    suspend fun <T: Any> queryOneWithIncludes(
        query: String,
        parameters: Map<String, Any> = emptyMap(),
        type: KType,
    ): KorvusResult<QueryOneWithIncludesResult<T>>

    /**
     * Performs a query on the database and returns the results
     *
     * @param query the query to perform on the database
     * @param parameters parameters that will be substituted for placeholders in the query
     * @param type the type of entities that are returned from the server
     * @param start the document to start at when paging. Paging is disabled if null
     * @param pageSize the number of documents to return per page. Paging is disabled if null
     */
    suspend fun <T: Any> queryMany(
        query: String,
        parameters: Map<String, Any?> = emptyMap(),
        type: KType,
        start: Int? = null,
        pageSize: Int? = null,
    ): KorvusResult<QueryResult<T>>

    /**
     * Performs a query on the database that deletes all matching documents
     *
     * @param query the query to perform on the database
     * @param parameters parameters that will be substituted for placeholders in the query
     */
    suspend fun deleteByQuery(
        query: String,
        parameters: Map<String, Any?> = emptyMap(),
    ): KorvusResult<Unit>

    /**
     * Performs a query on the database that patches all matching documents
     *
     * @param query the query to perform on the database
     * @param parameters parameters that will be substituted for placeholders in the query
     */
    suspend fun patchByQuery(
        query: String,
        parameters: Map<String, Any?> = emptyMap(),
    ): KorvusResult<Unit>
}
